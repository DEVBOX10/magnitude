# Modular Agent Memory Architecture with Self-Rendering Observations

This document outlines a modular agent memory system. Key components include:
- **Connectors**: Stateful modules that observe specific aspects of an environment (e.g., web page, file system). They diff their own internal state to detect changes.
- **Observations**: Granular, self-rendering data objects produced by Connectors when they detect changes or significant events.
- **AgentMemory**: Stores a chronological history of agent thoughts and "turns" (actions taken and the observations that resulted). It builds a context object for an LLM.

## Core Concepts

1.  **`Observation` (TypeScript Interface)**:
    *   Represents a specific event or change detected by a `Connector`.
    *   Contains a `renderToBaml()` method. Data needed for rendering is stored as direct properties on the `Observation` instance itself (e.g., `this.imageData`, `this.messageText`) and accessed by `renderToBaml` using `this`.
    *   The `sourceConnectorId` is a required property. Timestamps are associated with the broader "Thought" or "Turn" in `AgentMemory`.

2.  **`AgentConnector` (TypeScript Interface)**:
    *   A module responsible for a specific domain of interaction or observation (e.g., web browsing, file system).
    *   Typically stateful: it maintains its own internal state and compares it against the current environment state after an action to generate `Observation`s.
    *   Exposes a `getObservations()` method, called by the agent orchestrator after an action, to report new `Observation`s.

3.  **`AgentMemory` (TypeScript Class)**:
    *   Records a history of agent activities, including:
        *   `Thoughts`: Internal monologue or reasoning steps of the agent.
        *   `Turns`: An `Action` taken by the agent, paired with all `Observation`s generated by Connectors in response to that action.
    *   Provides a `buildContext()` method to assemble a `MemoryContext` object (defined in BAML) to be sent to an LLM. This context includes both the chronological history and a snapshot of the current relevant agent state.

4.  **`MemoryContext` (BAML Class)**:
    *   The data structure passed to the LLM.
    *   Contains a `history` of thoughts and action/observation turns.
    *   Includes top-level fields for the current snapshot of the environment (e.g., current timestamp, screenshot, tab information).

## Key Interfaces and Structures

### 1. `Observation` (TypeScript)

```typescript
// Defined in: e.g., packages/magnitude-core/src/agent/observationTypes.ts
import { Image as BamlImage } from "@boundaryml/baml"; // Or your BAML client path

// Union of types for BAML MemoryContext.history
export type BamlRenderable = BamlImage | string;

export interface Observation {
    sourceConnectorId: string; // ID of the Connector instance that produced this
    // Data for rendering is captured in the closure of the renderToBaml method.
    // Timestamps are associated with the broader "Thought" or "Turn" in AgentMemory.

    /**
     * Renders this observation's payload into BAML-renderable forms.
     * Implemented by the connector when creating the Observation instance.
     */
    renderToBaml: () => BamlRenderable[]; 
}
```

### 2. `AgentConnector` Interface (TypeScript)

```typescript
// Defined in: e.g., packages/magnitude-core/src/connectors/index.ts
import { Observation } from "@/agent/observationTypes"; // Adjust path

// Connector options are typically passed via constructor.
export interface AgentConnector {
    id: string; // Unique identifier for the connector instance

    // ... onStart(), onStop(), getActionSpace() ...

    /**
     * Renders the connector's current, most relevant state as BAML-renderable items.
     * This is used to populate the "current state" portion of the MemoryContext.
     * Should return an empty array if the connector has no relevant current state to contribute
     * or if it's not currently "active" in providing such state.
     */
    renderCurrentStateToBaml(): Promise<BamlRenderable[]>;

    /**
     * Called by the Agent Orchestrator after an action has been performed.
     * The connector should:
     * 1. Capture its current relevant state (e.g., current URL, screenshot of a UI).
     * 2. Compare it with its internally stored "previous" state to detect changes.
     * 3. If significant changes or events are detected, generate one or more Observation objects.
     *    The data needed for rendering these observations is captured in the closure of their
     *    `renderToBaml` methods.
     * 4. Update its internal "previous state" to the current state for the next diffing cycle.
     * 5. Return an array of the generated Observation objects.
     */
    getObservations(): Promise<Observation[]>; 
}
```

### 3. `AgentMemory` (Conceptual Structure - TypeScript)

```typescript
// Defined in: e.g., packages/magnitude-core/src/agent/memory.ts
import { Action } from "@/actions/types"; // Adjust path
import { Observation, BamlRenderable } from "./observationTypes"; // Adjust path
import { BamlImage } from "@boundaryml/baml"; // Assuming BamlImage is available

// BAML client output types (conceptual for this document)
// These would be generated by your BAML schema.
interface BamlThought { timestamp: string; message: string; }
interface BamlTurn { timestamp: string; action: string; observations: (string | BamlImage)[]; }

// Represents the current state contribution from a single connector (generated by BAML)
interface ConnectorState { 
    connector_id: string;
    elements: BamlRenderable[];
}
interface MemoryContext {
  history: (BamlThought | BamlTurn)[];
  current_timestamp: string;
  current_connector_states: ConnectorState[]; 
}

// Internal storage structure for AgentMemory
type StoredHistoryEntry = 
    | { entryType: 'thought'; timestamp: number; content: string; }
    | { entryType: 'turn'; timestamp: number; action: Action; observations: Observation[]; };

export class AgentMemory {
    private history: StoredHistoryEntry[] = [];

    constructor() { /* ... */ }

    public recordThought(content: string, timestamp?: number): void {
        this.history.push({
            entryType: 'thought',
            timestamp: timestamp || Date.now(),
            content
        });
    }

    public recordTurn(action: Action, observations: Observation[], timestamp?: number): void {
        this.history.push({
            entryType: 'turn',
            timestamp: timestamp || Date.now(),
            action,
            observations
        });
    }

    // activeConnectors would be a list of currently operational AgentConnector instances,
    // managed by the agent orchestrator and passed to buildContext.
    public async buildContext(activeConnectors: AgentConnector[]): Promise<MemoryContext> {
        const processed_history: (BamlThought | BamlTurn)[] = [];

        for (const entry of this.history) {
            const formattedTime = new Date(entry.timestamp).toTimeString().split(' ')[0]; // HH:MM:SS

            if (entry.entryType === 'thought') {
                processed_history.push({
                    timestamp: formattedTime,
                    message: entry.content
                } as BamlThought);
            } else if (entry.entryType === 'turn') {
                const turn_observation_items: BamlRenderable[] = [];
                for (const observation of entry.observations) {
                    try {
                        const items = observation.renderToBaml();
                        turn_observation_items.push(...items);
                    } catch (e) {
                        console.error(`Error rendering observation from ${observation.sourceConnectorId}:`, e);
                    }
                }
                processed_history.push({
                    timestamp: formattedTime,
                    action: JSON.stringify(entry.action), // Or a more structured action representation
                    observations: turn_observation_items
                } as BamlTurn);
            }
        }

        const connector_states_for_context: ConnectorState[] = [];
        const current_timestamp_str = new Date().toTimeString().split(' ')[0]; // Timestamp of context creation

        for (const connector of activeConnectors) {
            try {
                const stateElements = await connector.renderCurrentStateToBaml(); 
                if (stateElements && stateElements.length > 0) {
                    connector_states_for_context.push({
                        connector_id: connector.id,
                        elements: stateElements
                    });
                }
            } catch (e) {
                console.error(`Error rendering current state from ${connector.id}:`, e);
                // Optionally, represent this error in the state:
                connector_states_for_context.push({
                    connector_id: connector.id,
                    elements: [`[Error: Could not render state for ${connector.id}]`]
                });
            }
        }

        return {
            history: processed_history,
            current_timestamp: current_timestamp_str,
            current_connector_states: connector_states_for_context
        };
    }
}
```

### 4. BAML `MemoryContext` Definition

This section defines the BAML classes that form the `MemoryContext` passed to the LLM.

```baml
// Defined in your BAML schema files
// (BamlImage class is assumed to be defined and available from your BAML setup)

// Represents an agent's thought.
class BamlThought {
  timestamp string    // Timestamp of the thought (e.g., "HH:MM:SS" format)
  message string      // The content of the thought
}

// Represents a single turn of interaction: an action and its resulting observations.
class BamlTurn {
  timestamp string                  // Timestamp of the turn (e.g., "HH:MM:SS" format)
  action string                     // Stringified JSON of the Action object for this turn
  observations (string | Image)[]   // All rendered items from this turn's observations
}

// Represents the current state contribution from a single connector
class ConnectorState {
  connector_id string                  // The ID of the connector (e.g., "web", "filesystem")
  elements (string | Image)[]         // The BAML-renderable state items from this connector
}

// The main context object passed to the LLM.
// client.GenerateText(prompt_template, input)
// input MemoryContext
class MemoryContext {
  history (BamlThought | BamlTurn)[] // Chronological log of thoughts and action-observation turns

  // Current environment state
  current_timestamp string           // Timestamp of when this context was created (e.g., "HH:MM:SS")
  current_connector_states ConnectorState[] // Current state from all active connectors, grouped by connector
}
```

## `WebInteractionConnector` Specifics

The `WebInteractionConnector` is an example of a state-diffing connector.

### 1. `WebConnectorStateData` (TypeScript)

```typescript
// Potentially in: packages/magnitude-core/src/connectors/webConnectorTypes.ts
import { Screenshot as RawScreenshotData, TabState as RawTabStateData } from "@/web/types"; // Adjust path

export interface WebConnectorStateData {
    url?: string;
    pageTitle?: string;
    screenshot?: RawScreenshotData;
    tabs?: RawTabStateData;
    // Add other relevant serializable state.
}

// Payload types are no longer needed here as data is captured in renderToBaml closures.
```

### 2. `WebInteractionConnector` Implementation Details

```typescript
// In: packages/magnitude-core/src/connectors/webConnector.ts
import { AgentConnector } from "."; // Adjust path to AgentConnector interface
import { WebConnectorStateData } from "./webConnectorTypes"; // Adjust path
import { Observation, BamlRenderable } from "@/agent/observationTypes"; // Adjust path to Observation interface
import { WebHarness } from "@/web/harness"; // Adjust path
import { deepEquals } from "@/common/util"; // Assuming a deepEquals utility
import { Image as BamlImage } from "@boundaryml/baml"; // Adjust path

export class WebInteractionConnector implements AgentConnector {
    public readonly id: string = "web";
    private harness: WebHarness;
    private previousState: WebConnectorStateData | undefined = undefined;

    constructor(harness: WebHarness) { // Options removed from interface, pass via constructor if needed
        this.harness = harness;
    }

    // ... onStart, onStop, getActionSpace ...

    private async captureCurrentState(): Promise<WebConnectorStateData> {
        const page = this.harness.page!;
        const [url, pageTitle, screenshot, tabs] = await Promise.all([
            page.url(),
            page.title(),
            this.harness.screenshot(),
            this.harness.retrieveTabState()
        ]);
        return { url, pageTitle, screenshot, tabs };
    }

    async getObservations(): Promise<Observation[]> {
        const currentState = await this.captureCurrentState(); // Captures url, pageTitle, screenshot, tabs
        const observations: Observation[] = [];

        if (this.previousState) {
            // Only generate an observation if the screenshot image has changed.
            if (currentState.screenshot?.image !== this.previousState.screenshot?.image) {
                // Create an observation object with direct data properties.
                const screenUpdateObservation = {
                    sourceConnectorId: this.id,
                    // Data for rendering is stored directly on this object:
                    type: "screenUpdate", // Optional descriptor
                    imageBase64: currentState.screenshot!.image,
                    currentUrlForCaption: currentState.url, // Store URL for context in caption

                    renderToBaml: function() { 
                        // 'this' refers to screenUpdateObservation.
                        // Access properties like this.imageBase64, this.currentUrlForCaption.
                        const caption = `Screen update. Current URL: ${this.currentUrlForCaption || 'N/A'}`;
                        const bamlImg = BamlImage.fromBase64('image/png', this.imageBase64);
                        return [caption, bamlImg];
                    }
                };
                observations.push(screenUpdateObservation as Observation);
            }
            // Other diffs (URL, tabs) are not generating observations here to match simpler existing behavior.
            // These details are part of `currentState` and would be available via `renderCurrentStateToBaml()`
            // for the MemoryContext's current state section, rather than as historical change observations.
        } else { 
            // Initial state capture: provide initial URL and screenshot.
            const initialStateObservation = {
                sourceConnectorId: this.id,
                type: "initialState", // Optional descriptor
                initialUrl: currentState.url,
                initialPageTitle: currentState.pageTitle,
                initialImageBase64: currentState.screenshot?.image,

                renderToBaml: function() {
                    // 'this' refers to initialStateObservation.
                    const initialBaml: BamlRenderable[] = [];
                    if (this.initialUrl) {
                        initialBaml.push(`[${this.sourceConnectorId}] Initial page: ${this.initialUrl} (${this.initialPageTitle || 'N/A'})`);
                    }
                    if (this.initialImageBase64) { // Check if screenshot image exists
                        initialBaml.push(BamlImage.fromBase64('image/png', this.initialImageBase64));
                    }
                    return initialBaml;
                }
            };
            observations.push(initialStateObservation as Observation);
        }

        this.previousState = currentState; // Update previous state (which includes URL, tabs, etc.) for the next cycle.
        return observations;
    }
}
```

## Agent Orchestrator Flow (Simplified)

1.  After an `Action` is performed:
    *   Initialize `allObservationsForAction: Observation[] = []`.
    *   If the action itself declares observations (e.g., `action.getDirectObservations()`):
        *   `allObservationsForAction.push(...action.getDirectObservations());`
    *   For each active `connector` (like `webConnector`):
        *   `const newObservations = await connector.getObservations();`
        *   `allObservationsForAction.push(...newObservations);`
    *   `agentMemory.recordTurn(action, allObservationsForAction);` // (or agentMemory.inscribeActionTurn)

This architecture promotes modularity:
- `AgentMemory` manages the chronological log of thoughts and action/observation turns.
- `Connectors` are experts in their domains, managing their own state and producing focused `Observation`s.
- `Observation`s are self-contained in their rendering logic.
- The `AgentMemory.buildContext` method assembles the final comprehensive context for the LLM, combining historical narrative with a current environmental snapshot.

## Design Considerations and Challenges

### Modular Current State Aggregation

The `MemoryContext` now includes a `current_connector_states` field, which is a list of `ConnectorState` objects. Each `ConnectorState` contains the `connector_id` and an array of `elements` (strings or images) representing that connector's view of the current environment. This approach relies on each `AgentConnector` implementing a `renderCurrentStateToBaml()` method.

**Key Aspects of this Approach:**

*   **Connector Responsibility**: Each `AgentConnector` is responsible for determining what aspects of its current state are relevant and how to render them as `BamlRenderable` items. For example:
    *   A `WebInteractionConnector` might render the current URL, page title, a screenshot, and active tab information.
    *   A `FileSystemConnector` might render the current working directory and a listing of its contents.
    *   A `CodeEditorConnector` might render the path to the open file and perhaps a snippet around the cursor.
*   **`AgentMemory.buildContext` Role**: The `AgentMemory.buildContext` method iterates through all active connectors provided by the Agent Orchestrator. It calls `renderCurrentStateToBaml()` on each and aggregates the results into the `current_connector_states` list in the `MemoryContext`.
*   **LLM Consumption**: The LLM prompt can be structured to iterate through `current_connector_states`. Using the `connector_id` (e.g., by wrapping each connector's state elements in tags like `<web_connector_state>...</web_connector_state>`), the LLM can clearly distinguish the source and nature of different pieces of current state information.

**Advantages:**

*   **Enhanced Modularity**: `AgentMemory` does not need to understand the specifics of each connector's state. It simply collects rendered state items.
*   **Clear Attribution**: The source of each piece of current state information is explicit in the `MemoryContext`.
*   **Flexibility**: Connectors can decide what's important to include in their current state representation.

**Considerations:**

*   **Prompt Engineering**: The LLM prompt needs to be designed to effectively parse and utilize the `current_connector_states` list, potentially using the `connector_id` to interpret the `elements` correctly.
*   **Volume of State Information**: If many connectors provide verbose state, the `current_connector_states` list could become large. Connectors should be designed to provide concise yet sufficient current state information. The orchestrator might also play a role in deciding which connectors are asked to provide their current state for a given turn.
*   **Ordering**: The order of `ConnectorState` objects in the `current_connector_states` list (determined by the order of `activeConnectors` passed to `buildContext`) might influence LLM interpretation. This order should be consistent or managed thoughtfully.
